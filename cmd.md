sqlx-cli工具：
only for Postgres:
    cargo install sqlx-cli --no-default-features --features native-tls,postgres
----------------------------------------------------------------------------------------

.env文件的意义：
# sqlx在编译时与Postgres进行交互，已检查查询是否合法，
# 但依赖DATABASE_URL环境变量确认数据库的位置。
# sqlx将从.env文件中读取DATABASE_URL,省去了每次都要重新导出环境变量的麻烦。
# .env文件 仅与 开发过程、构建和测试步骤相关。
-----------------------------------------------------------------------------------------

curl http://127.0.0.1:8000/health_check -v

curl -i -X POST -d 'email=thomas_maiinn%40hostmail.con&name=Toiim' http://127.0.0.1:8000/subscriptions

-----------------------------------------------------------------------------------------
docker build --tag zero2prod --file Dockerfile .

----------------------------------------------------------------------------------------------
sqlx 的"offline"离线模式：
    cargo sqlx preare -- --lib
    prepare执行的与调用cargo build是所做的工作类似,它将这些查询的结果保存在一个元数据文件(sqlx-data.json)中，由sqlx自行检测，可以完全跳过查询，从而执行离线构建。
    --lib, 由于所有的SQL查询都被放在以'lib.rs'为根的模块中，因此这里必须要用参数指明命令作用于lib部分。

------------------------------------------------------------------------------------------------

使用环境变量注入机密信息：例如数据库root用户的用户名和密码

-------------------------------------------------------------------------------------------------
serde-aux crate从环境变量中提取整数
--------------------------------------------------------------------------------------------------
生成环境中，与数据库通信提供加密通信，即SSL模式
-----------------------------------------------------------------------------------------------
利用Rust的类型系统完全消除输入数据的无效性
------------------------------------------------------------------------------------------------
实现AsRef<str>， 方可使用as_ref()
------------------------------------------------------------------------------------------------
? 运算符的语法糖：let Err(err) = 函数名(){ ... return Err(error)}; ? 只能在返回Result的函数中使用
------------------------------------------------------------------------------------------------
validator crate 验证email格式是否有效
------------------------------------------------------------------------------------------------
属性测试：fake crate提供基本数据类型和高级对象(IP地址、国家代码等)的生成逻辑，尤其是电子邮件，即生成随机测试数据
-----------------------------------------------------------------------------------------------
两个主流的属性测试工具：quickcheck和proptest；cargo test valid_emails -- --nocapture查看有效的电子邮件地址
-------------------------------------------------------------------------------------------------------
N实现TryFrom<T> 后，使用T.try_into()可返回N类型（将T类型转换为N类型）；两种类型之间是可能会失败的转换，会消耗输入的值,
---------------------------------------------------------------------------------------------------------
cargo check --all-targets
---------------------------------------------------------------------------------------------------------
如何测试REST客户端:用wiremock模拟服务器进行单元测试，使用fake()生成随机数据（明确不关注输入，他们的值不影响测试的结果）
------------------------------------------------------------------------------------------------------------
json方法会将Content-Type头设置为application/json
------------------------------------------------------------------------------------------------------------
添加授权令牌，Client使用header()设置授权请求头
--------------------------------------------------------------------------------------------------------------
7.2.5使用wiremock提供的匹配器matchers验证请求头(header)、请求端点(path)、请求方法(method)以及header_exists，而，
验证请求体则需要自己实现Match trait,且字段名称必须采用帕斯卡命名法#[serde(rename_all = "PascalCase")]
-------------------------------------------------------------------------------------------------------------------
7.2.5.1 字符串切片&str只是指向其他对象所拥有的内存缓存区的指针;在结构体中存储引用，需添加一个生命周期参数，
确保引用不会比指向的内存缓冲区存在更长的时间；
-------------------------------------------------------------------------------------------------------------------
7.2.6.1 reqwest::Client::send()方法只要获得服务器响应，不管状态码如何，就返回Ok！Response::error_for_status()对服务器返回错误，
则将响应转换为错误
--------------------------------------------------------------------------------------------------------------------
7.2.6.2一个经验法则：每当进行I/O操作时，都要设置超时时间！如果服务器的响应时间超过超时时间，则应该失败并返回错误;
--------------------------------------------------------------------------------------------------------------------
7.2.6.3重构测试辅助函数
--------------------------------------------------------------------------------------------------------------------
7.2.6.4reqwest的Client超时时间设置为可配置,默认1000毫秒
------------------------------------------------------------------------------------------------------------------
7.3.7利用了tests文件下的每个文件都是独立的可执行文件的优势,分解为更小且更易管理的模块; cargo build --tests; ls target/debug/deps | grep api;
---------------------------------------------------------------------------------------------------------------------
7.3.8.2-1提取启动代码，在启动逻辑中添加测试触发器，实现函数化代码
---------------------------------------------------------------------------------------------------------------------
7.3.9我们需要小心，不要把客户端逻辑分散在整个测试套件中(当API发生变化时，我们不想在数十个测试中去除某个端点路径末尾的s)
---------------------------------------------------------------------------------------------------------------------
7.6.3在线部署软件新版本，得先修改数据库模式，再部署软件新版本；对数据库的做法：对于新的必填地段，第1步：以非必填的形式添加字段后，原版本应能正常运行；
第2步：新版本部署到生产环境中；第3步：先对历史记录回填，然后才能修改这个字段的属性；第4步：运行测试用例，然后部署生产数据库；
------------------------------------------------------------------------------------------------------------------------
7.6.5部署新版本的软件，添加新表，可以直接添加，而原有的应用程序会忽略这个表；
-------------------------------------------------------------------------------------------------------------------------
7.7.2 linkify可以从请求中提取body里的链接
-------------------------------------------------------------------------------------------------------------------------
7.7.4 参数类型web:Query<Parameters> 仅在成功提取查询参数的情况下，调用处理函数；提取失败，返回400
-------------------------------------------------------------------------------------------------------------------------
7.7.5.2 对于域名和协议，将根据应用程序运行的环境来确定：在测试环境中应该是http://127.0.0.1,在生产环境中应该是一条使用HTTPS的DNS记录；
---------------------------------------------------------------------------------------------------------------------------
7.7.5.3 重构集成测试
--------------------------------------------------------------------------------------------------------------------------
7.7.6.2 订阅令牌
--------------------------------------------------------------------------------------------------------------------------
7.8.1 应用程序中，当数据库对多表同时进行多种操作时，若出错，难以理清数据库可能的状态；事务，是一种将多个有关联的操作组合在一起的方法，
使他们成为一个基本执行单位，数据库保证事务中的所有操作要么全部成功，要么全部失败；BEGIN语句后的所有查询都会成为事务的一部分，
事务以COMMIT语句结束；事务中任何一个操作失败，数据库都将回滚；
-----------------------------------------------------------------------------------------------------------------------------
7.8.3 如果不提交事务，则必定回滚；Transaction::commit用于提交改动，Transaction::rollback用于回滚整个操作；
-----------------------------------------------------------------------------------------------------------------------------
8.2 错误类型应当携带失败场景的上下文，并以此发布一个日志事件，为操作人员提供细节足够多的报告，使其得以发现并解决问题；对于系统内部错误，
我们利用类型、方法、字段提供相应的信息，对于系统交互错误，我们使用状态码，而错误报告则相反，它是提供给人类的，要根据受众进行调整，对于操作人
员则尽可能多的错误信息，对于用户则是提供足够调整预期行为的信息即可；

export RUST_LOG="sqlx=error,info"
export TEST_LOG=enabled
cargo t subscribe_fails_if_there_is_a_fatal_database_error | bunyan
enabled: 这个值表示 “启用测试日志输出”,这三条命令组合在一起,测试运行时的所有日志都能被显示出来
日志中exception.details和exception.message记录底层的根本原因
------------------------------------------------------------------------------------------------------------------------------
8.2.1 跟踪错误的根本原因(日志中exception.details和exception.message，记录的错误日志简洁而深入); "孤儿规则":对于外来的类型，不允许实现一个外来的trait；
Debug trait应当提供一种对开发者友好的格式，尽可能将类型结构表达出来，几乎所有被设置为公开的类型都应该实现Debug,而Dispaly trait则相反，
它应当提供一种对用户友好的格式，大部分类型都不会实现Display,且不能通过#[derive(Display)]宏来自动实现；
'?'操作符帮我们自动调用'Into' trait,这样无须显示的调用'map_err'方法；
------------------------------------------------------------------------------------------------------------------------------
8.2.2 泛型参数在编译时被解析（静态分发），而trait对象会产生运行时开销（动态分发）；std::Error trait的实现返回一个trait对象，因为这样
开发者就可以获得当前错误的根本原因，同时擦除底层错误的类型，它不会暴漏底层错误的类型，我们只能使用Error trait提供的方法：不同的表示
格式(Debug和Display),使用source方法可以在错误传播链上找到前一个环节；
------------------------------------------------------------------------------------------------------------------------------
8.2.2.3 (新增) 总结：一：StoreTokenError(pub sqlx) 为了可以转换为actix_web::Error，需要实现 ResponseError，这样错误日志比较简洁且深入；
二：StoreTokenError(pub sqlx)去实现 std::error::Error trait, 其Debug的实现，可以调用手写的遍历错误传播链的函数，直到打印出底层错误；
--------------------------------------------------------------------------------------------------------------------------------
8.3.1 store_token()理应与REST或HTTP没有关系，但我们却为其返回的错误类型实现了Web框架中的一个Trait(即：ResponseError),导致可能会有其他的
入口调用store_token，失败时返回500，但我们并不想要的；当错误发生时，选择合适的HTTP状态码是请求处理函数的职责，不能交给系统的其他部分；要做
到合理的关注点分离，必须引入另外一个错误类型SUbscriberError,并为其实现ResponseError，这样就和HTTP的逻辑关联起来了；
---------------------------------------------------------------------------------------------------------------------------------
8.3.2 错误类型StoreTokenError需要实现自动=转换成SubscriberError类型，最常见的方法是使用枚举：将所有需要处理的错误类型都设为枚举的变体,并为每个
变体所包装的内部类型实现From trait后，就可以方便的使用'?'操作符；
---------------------------------------------------------------------------------------------------------------------------------
8.3.3  DataBaseError(sqlx::Error)只知道类型，还无法分辨使用的具体变体是什么，因此不应该为sqlx::Error实现From trait,应该在各个场景
下使用map_err进行相应的转换; 8.2章是传播错误的基本实现原理，8.3.3是对传播错误的优化
----------------------------------------------------------------------------------------------------------------------------------
8.3.4 减少自己实现的传播错误代码，可以使用thiserror crate,使用宏来生成样板代码；#[derive(/* */)]这个宏在编译时接受SubscriberError作为输入，
并返回一组标记流作为输出；在#[derive(thiserror::Error)]的上下文中，可以使用其他属性来实现一些行为：#[error(/* /*)]属性,修饰的枚举变体定义
了Display trait的标识格式；#[error("{0}")]中的{0}模仿的是元组语法(即self.0),代指变体所包装的String字段;#[source]属性,被用于指定
Error::source方法返回的错误根本原因；#[from]属性,自动为所处的错误类型派生了该属性所修饰的字段的From trait，同时#[from]属性所修饰的字段也
被用于作为根本原因，这样就可以省略#[source]属性(即不用写#[source] #[from] reqwest::Error这样的代码)；
-------------------------------------------------------------------------------------------------------------------------------------
8.4   8.3.4中实现的SubscriberError类型的枚举变体被用于：一.生成应返回给API调用者的响应(ResponseError)，二.提供相关的诊断信息(Error::source,Debug
,Display等),但暴漏了处理函数大量的处理细节，且这种方法不具有良好的可拓展性；处理函数应当返回给调用者一个合适抽象层次上的错误类型,理想中的错误类型
应该是一个变体对应400 Bad Request,另外一个UnexpectedError应是一个隐藏了细节的500 InternalServerError；

关于Box<dyn std::error::Error> ，由于在编译时无法得知 trait对象的大小，因此我们使用Box将dyn std::error::Error包装起来：trait对象可以用于存储
不同的类型，这些类型很可能有不同的内存布局。使用Rust的属于来说，它们是不确定大小的类型---它们没有实现Sized标识特质。Box可以将特质对象存储在堆上，
我们可以将其作为指向堆内容的指针，存储在SubscriberError::UnexpectedError中---在编译时指针是确定大小的---问题解决了，我们类型又实现了Sized.
---------------------------------------------------------------------------------------------------------------------------------------
8.4.1 anyhow::Error用于包装一个动态的错误类型,即将对应方法(context()方法)返回的错误类型转换为amyhow::Error类型，并为错误类型提供额外的上下文，
实现了该字段原来的功能；
当需要根据不同的错误采用不同的处理方法，就是用枚举类型，对不同的错误使用不同的变体，此时使用thiserror可以减少样板代码量；当在发生错误时只能终止流程，
并将错误报告给操作人员，就使用擦除了类型的错误，并屏蔽获取内部错误信息的接口，anyhow和ayre为此提供了便捷的API接口；
----------------------------------------------------------------------------------------------------------------------------------------
8.5 错误日志由谁来记? 程序中可能会有多处记录错误，不该将同一个错误记录多次，多余的日志会让人产生困惑(真的发生了多次吗？)；最重要的原则是：错误只在
被处理时才应该记录；如果当前的函数只是将错误传播到上游(例如通过?操作符)，那么它就不应该记录这个错误，但它可以给这个错误添加合适的上下文；倘若错误被
一路传播到请求处理器，那么就交由某个中间件对其做合适的记录。
----------------------------------------------------------------------------------------------------------------------------------------
9.2.2 关于wiremock::Mock，通过mount(),只要底层的MockServer启动并运行，我们所指定的行为就会一直有效，而使用mount_as_scoped(),我会得到一个
守护对象，即MockGuard，它有一个Drop实现，当它超出范围时，wiremock会告诉底层的MockServer停止MockGuard遵守指定的mock行为，换句话说：MockGuard在最后
不再向POST /email 返回200；当MockGuard被丢弃时，会立即检查对scoped mock的期望是否得到验证。
------------------------------------------------------------------------------------------------------------------------------------------
9.5-9.6 处理HTML表单，使用Content/Type的application/x-www-form-urlencoded,不受网页的表单约束，使用JSON,这个是构建REST API的一个常见选择；
sqlx::query_as!()将检索到的行，映射到其第一个参数中指定的类型；
--------------------------------------------------------------------------------------------------------------------------------------------
9.7 with_context()与context()相近，将Result的错误变体转换为anyhow::Error,同时用上下文信息来填充它，但with_context()是惰性的；使用context()每次发送
邮件是都分配这个字符串，相反，使用with_context()只有在发送邮件失败时才会调用闭包；
---------------------------------------------------------------------------------------------------------------------------------------------
9.8 query!: 用于临时性查询或返回的列不适合映射到现有结构体的情况。它会在编译时检查查询并生成一个匿名记录结构体;query_as!: 用于将查询结果映射到预定义的、
明确命名的结构体,这更有利于代码的组织、复用和文档化，尤其是在处理多个返回列或复杂查询时;

数据的一致性：假设软件永不变化，这个推理是合理的。但是，我们正在为高频部署进行优化，存储在Postgres实例中的数据，在应用程序的新旧版本之间产生了时间上的耦合。
我们从数据中查询到的邮件被应用程序的前一个版本标记为有效，而在当前的版本中可能无效；

保证数据的一致性：我们需要基于领域的要求，根据具体的情况来评估这个问题。有时，处理无效的记录是不可接受的---程序应该失败，操作人员必须介入纠正无效的记录；有时
，我们需要处理所有的历史记录(如分析)，并且应该对数据做出最小的假设---字符串是最安全的方式。在我们的例子中，可以进行折中：在获取下一期邮件简报的收件人名单时，
跳过无效的邮件。针对每个无效地址发出警告，允许操作人员发现问题，并在未来的某个时间点纠正错误的记录。实现方式：使用filter_map();
-----------------------------------------------------------------------------------------------------------------------------------------------
9.8.1 责任界限：业务层面的决定，最好放在业务层面，get_confrimed_subscriber()应该只存在存储层和领域层之间充当一个适配器，它处理数据库特定的部分(即查询)
和逻辑映射，但在映射或查询失败时将处理的决定权交给调用者;

Err(anyhow::anyhow!(error)): 使用 anyhow! 宏将原始的、特定的错误 error 包装成一个新的、类型擦除的 anyhow::Error。然后将其包装在 Err() 中。
tracing::warn!(error.cause_chain = ?error, "some message"):这段是tracing 宏的高级用法，日志级别: warn! - 错误级别宏,字段赋值: field_name = expression,
格式化符号: ? 或 % 前缀(?调试格式化操作符,% 操作符-显示格式),消息模板: 字符串字面值,