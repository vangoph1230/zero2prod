sqlx-cli工具：
only for Postgres:
    cargo install sqlx-cli --no-default-features --features native-tls,postgres
----------------------------------------------------------------------------------------

.env文件的意义：
# sqlx在编译时与Postgres进行交互，已检查查询是否合法，
# 但依赖DATABASE_URL环境变量确认数据库的位置。
# sqlx将从.env文件中读取DATABASE_URL,省去了每次都要重新导出环境变量的麻烦。
# .env文件 仅与 开发过程、构建和测试步骤相关。
-----------------------------------------------------------------------------------------

curl http://127.0.0.1:8000/health_check -v

curl -i -X POST -d 'email=thomas_maiinn%40hostmail.con&name=Toiim' http://127.0.0.1:8000/subscriptions

-----------------------------------------------------------------------------------------
docker build --tag zero2prod --file Dockerfile .

----------------------------------------------------------------------------------------------
sqlx 的"offline"离线模式：
    cargo sqlx preare -- --lib
    prepare执行的与调用cargo build是所做的工作类似,它将这些查询的结果保存在一个元数据文件(sqlx-data.json)中，由sqlx自行检测，可以完全跳过查询，从而执行离线构建。
    --lib, 由于所有的SQL查询都被放在以'lib.rs'为根的模块中，因此这里必须要用参数指明命令作用于lib部分。

------------------------------------------------------------------------------------------------
登录流程：需要一个GET端点来返回HTML表单，一个POST端点来处理提交的信息;

使用环境变量注入机密信息：例如数据库root用户的用户名和密码

-------------------------------------------------------------------------------------------------
serde-aux crate从环境变量中提取整数
--------------------------------------------------------------------------------------------------
生成环境中，与数据库通信提供加密通信，即SSL模式
-----------------------------------------------------------------------------------------------
利用Rust的类型系统完全消除输入数据的无效性
------------------------------------------------------------------------------------------------
实现AsRef<str>， 方可使用as_ref()
------------------------------------------------------------------------------------------------
? 运算符的语法糖：let Err(err) = 函数名(){ ... return Err(error)}; ? 只能在返回Result的函数中使用
------------------------------------------------------------------------------------------------
validator crate 验证email格式是否有效
------------------------------------------------------------------------------------------------
属性测试：fake crate提供基本数据类型和高级对象(IP地址、国家代码等)的生成逻辑，尤其是电子邮件，即生成随机测试数据
-----------------------------------------------------------------------------------------------
两个主流的属性测试工具：quickcheck和proptest；cargo test valid_emails -- --nocapture查看有效的电子邮件地址
-------------------------------------------------------------------------------------------------------
N实现TryFrom<T> 后，使用T.try_into()可返回N类型（将T类型转换为N类型）；两种类型之间是可能会失败的转换，会消耗输入的值,
---------------------------------------------------------------------------------------------------------
cargo check --all-targets
---------------------------------------------------------------------------------------------------------
如何测试REST客户端:用wiremock模拟服务器进行单元测试，使用fake()生成随机数据（明确不关注输入，他们的值不影响测试的结果）
------------------------------------------------------------------------------------------------------------
json方法会将Content-Type头设置为application/json
------------------------------------------------------------------------------------------------------------
添加授权令牌，Client使用header()设置授权请求头
--------------------------------------------------------------------------------------------------------------
7.2.5使用wiremock提供的匹配器matchers验证请求头(header)、请求端点(path)、请求方法(method)以及header_exists，而，
验证请求体则需要自己实现Match trait,且字段名称必须采用帕斯卡命名法#[serde(rename_all = "PascalCase")]
-------------------------------------------------------------------------------------------------------------------
7.2.5.1 字符串切片&str只是指向其他对象所拥有的内存缓存区的指针;在结构体中存储引用，需添加一个生命周期参数，
确保引用不会比指向的内存缓冲区存在更长的时间；
-------------------------------------------------------------------------------------------------------------------
7.2.6.1 reqwest::Client::send()方法只要获得服务器响应，不管状态码如何，就返回Ok！Response::error_for_status()对服务器返回错误，
则将响应转换为错误
--------------------------------------------------------------------------------------------------------------------
7.2.6.2一个经验法则：每当进行I/O操作时，都要设置超时时间！如果服务器的响应时间超过超时时间，则应该失败并返回错误;
--------------------------------------------------------------------------------------------------------------------
7.2.6.3重构测试辅助函数
--------------------------------------------------------------------------------------------------------------------
7.2.6.4reqwest的Client超时时间设置为可配置,默认1000毫秒
------------------------------------------------------------------------------------------------------------------
7.3.7利用了tests文件下的每个文件都是独立的可执行文件的优势,分解为更小且更易管理的模块; cargo build --tests; ls target/debug/deps | grep api;
---------------------------------------------------------------------------------------------------------------------
7.3.8.2-1提取启动代码，在启动逻辑中添加测试触发器，实现函数化代码
---------------------------------------------------------------------------------------------------------------------
7.3.9我们需要小心，不要把客户端逻辑分散在整个测试套件中(当API发生变化时，我们不想在数十个测试中去除某个端点路径末尾的s)
---------------------------------------------------------------------------------------------------------------------
7.6.3在线部署软件新版本，得先修改数据库模式，再部署软件新版本；对数据库的做法：对于新的必填地段，第1步：以非必填的形式添加字段后，原版本应能正常运行；
第2步：新版本部署到生产环境中；第3步：先对历史记录回填，然后才能修改这个字段的属性；第4步：运行测试用例，然后部署生产数据库；
------------------------------------------------------------------------------------------------------------------------
7.6.5部署新版本的软件，添加新表，可以直接添加，而原有的应用程序会忽略这个表；
-------------------------------------------------------------------------------------------------------------------------
7.7.2 linkify可以从请求中提取body里的链接
-------------------------------------------------------------------------------------------------------------------------
7.7.4 参数类型web:Query<Parameters> 仅在成功提取查询参数的情况下，调用处理函数；提取失败，返回400
-------------------------------------------------------------------------------------------------------------------------
7.7.5.2 对于域名和协议，将根据应用程序运行的环境来确定：在测试环境中应该是http://127.0.0.1,在生产环境中应该是一条使用HTTPS的DNS记录；
---------------------------------------------------------------------------------------------------------------------------
7.7.5.3 重构集成测试
--------------------------------------------------------------------------------------------------------------------------
7.7.6.2 订阅令牌
--------------------------------------------------------------------------------------------------------------------------
7.8.1 应用程序中，当数据库对多表同时进行多种操作时，若出错，难以理清数据库可能的状态；事务，是一种将多个有关联的操作组合在一起的方法，
使他们成为一个基本执行单位，数据库保证事务中的所有操作要么全部成功，要么全部失败；BEGIN语句后的所有查询都会成为事务的一部分，
事务以COMMIT语句结束；事务中任何一个操作失败，数据库都将回滚；
-----------------------------------------------------------------------------------------------------------------------------
7.8.3 如果不提交事务，则必定回滚；Transaction::commit用于提交改动，Transaction::rollback用于回滚整个操作；
-----------------------------------------------------------------------------------------------------------------------------
8.2 错误类型应当携带失败场景的上下文，并以此发布一个日志事件，为操作人员提供细节足够多的报告，使其得以发现并解决问题；对于系统内部错误，
我们利用类型、方法、字段提供相应的信息，对于系统交互错误，我们使用状态码，而错误报告则相反，它是提供给人类的，要根据受众进行调整，对于操作人
员则尽可能多的错误信息，对于用户则是提供足够调整预期行为的信息即可；

export RUST_LOG="sqlx=error,info"
export TEST_LOG=enabled
cargo t subscribe_fails_if_there_is_a_fatal_database_error | bunyan
enabled: 这个值表示 “启用测试日志输出”,这三条命令组合在一起,测试运行时的所有日志都能被显示出来
日志中exception.details和exception.message记录底层的根本原因
------------------------------------------------------------------------------------------------------------------------------
8.2.1 跟踪错误的根本原因(日志中exception.details和exception.message，记录的错误日志简洁而深入); "孤儿规则":对于外来的类型，不允许实现一个外来的trait；
Debug trait应当提供一种对开发者友好的格式，尽可能将类型结构表达出来，几乎所有被设置为公开的类型都应该实现Debug,而Dispaly trait则相反，
它应当提供一种对用户友好的格式，大部分类型都不会实现Display,且不能通过#[derive(Display)]宏来自动实现；
'?'操作符帮我们自动调用'Into' trait,这样无须显示的调用'map_err'方法；
------------------------------------------------------------------------------------------------------------------------------
8.2.2 泛型参数在编译时被解析（静态分发），而trait对象会产生运行时开销（动态分发）；std::Error trait的实现返回一个trait对象，因为这样
开发者就可以获得当前错误的根本原因，同时擦除底层错误的类型，它不会暴漏底层错误的类型，我们只能使用Error trait提供的方法：不同的表示
格式(Debug和Display),使用source方法可以在错误传播链上找到前一个环节；
------------------------------------------------------------------------------------------------------------------------------
8.2.2.3 (新增) 总结：一：StoreTokenError(pub sqlx) 为了可以转换为actix_web::Error，需要实现 ResponseError，这样错误日志比较简洁且深入；
二：StoreTokenError(pub sqlx)去实现 std::error::Error trait, 其Debug的实现，可以调用手写的遍历错误传播链的函数，直到打印出底层错误；
--------------------------------------------------------------------------------------------------------------------------------
8.3.1 store_token()理应与REST或HTTP没有关系，但我们却为其返回的错误类型实现了Web框架中的一个Trait(即：ResponseError),导致可能会有其他的
入口调用store_token，失败时返回500，但我们并不想要的；当错误发生时，选择合适的HTTP状态码是请求处理函数的职责，不能交给系统的其他部分；要做
到合理的关注点分离，必须引入另外一个错误类型SUbscriberError,并为其实现ResponseError，这样就和HTTP的逻辑关联起来了；
---------------------------------------------------------------------------------------------------------------------------------
8.3.2 错误类型StoreTokenError需要实现自动=转换成SubscriberError类型，最常见的方法是使用枚举：将所有需要处理的错误类型都设为枚举的变体,并为每个
变体所包装的内部类型实现From trait后，就可以方便的使用'?'操作符；
---------------------------------------------------------------------------------------------------------------------------------
8.3.3  DataBaseError(sqlx::Error)只知道类型，还无法分辨使用的具体变体是什么，因此不应该为sqlx::Error实现From trait,应该在各个场景
下使用map_err进行相应的转换; 8.2章是传播错误的基本实现原理，8.3.3是对传播错误的优化
----------------------------------------------------------------------------------------------------------------------------------
8.3.4 减少自己实现的传播错误代码，可以使用thiserror crate,使用宏来生成样板代码；#[derive(/* */)]这个宏在编译时接受SubscriberError作为输入，
并返回一组标记流作为输出；在#[derive(thiserror::Error)]的上下文中，可以使用其他属性来实现一些行为：#[error(/* /*)]属性,修饰的枚举变体定义
了Display trait的标识格式；#[error("{0}")]中的{0}模仿的是元组语法(即self.0),代指变体所包装的String字段;#[source]属性,被用于指定
Error::source方法返回的错误根本原因；#[from]属性,自动为所处的错误类型派生了该属性所修饰的字段的From trait，同时#[from]属性所修饰的字段也
被用于作为根本原因，这样就可以省略#[source]属性(即不用写#[source] #[from] reqwest::Error这样的代码)；
-------------------------------------------------------------------------------------------------------------------------------------
8.4   8.3.4中实现的SubscriberError类型的枚举变体被用于：一.生成应返回给API调用者的响应(ResponseError)，二.提供相关的诊断信息(Error::source,Debug
,Display等),但暴漏了处理函数大量的处理细节，且这种方法不具有良好的可拓展性；处理函数应当返回给调用者一个合适抽象层次上的错误类型,理想中的错误类型
应该是一个变体对应400 Bad Request,另外一个UnexpectedError应是一个隐藏了细节的500 InternalServerError；

关于Box<dyn std::error::Error> ，由于在编译时无法得知 trait对象的大小，因此我们使用Box将dyn std::error::Error包装起来：trait对象可以用于存储
不同的类型，这些类型很可能有不同的内存布局。使用Rust的属于来说，它们是不确定大小的类型---它们没有实现Sized标识特质。Box可以将特质对象存储在堆上，
我们可以将其作为指向堆内容的指针，存储在SubscriberError::UnexpectedError中---在编译时指针是确定大小的---问题解决了，我们类型又实现了Sized.
---------------------------------------------------------------------------------------------------------------------------------------
8.4.1 anyhow::Error用于包装一个动态的错误类型,即将对应方法(context()方法)返回的错误类型转换为amyhow::Error类型，并为错误类型提供额外的上下文，
实现了该字段原来的功能；
当需要根据不同的错误采用不同的处理方法，就是用枚举类型，对不同的错误使用不同的变体，此时使用thiserror可以减少样板代码量；当在发生错误时只能终止流程，
并将错误报告给操作人员，就使用擦除了类型的错误，并屏蔽获取内部错误信息的接口，anyhow和ayre为此提供了便捷的API接口；
----------------------------------------------------------------------------------------------------------------------------------------
8.5 错误日志由谁来记? 程序中可能会有多处记录错误，不该将同一个错误记录多次，多余的日志会让人产生困惑(真的发生了多次吗？)；最重要的原则是：错误只在
被处理时才应该记录；如果当前的函数只是将错误传播到上游(例如通过?操作符)，那么它就不应该记录这个错误，但它可以给这个错误添加合适的上下文；倘若错误被
一路传播到请求处理器，那么就交由某个中间件对其做合适的记录。
----------------------------------------------------------------------------------------------------------------------------------------
9.2.2 关于wiremock::Mock，通过mount(),只要底层的MockServer启动并运行，我们所指定的行为就会一直有效，而使用mount_as_scoped(),我会得到一个
守护对象，即MockGuard，它有一个Drop实现，当它超出范围时，wiremock会告诉底层的MockServer停止MockGuard遵守指定的mock行为，换句话说：MockGuard在最后
不再向POST /email 返回200；当MockGuard被丢弃时，会立即检查对scoped mock的期望是否得到验证。
------------------------------------------------------------------------------------------------------------------------------------------
9.5-9.6 处理HTML表单，使用Content/Type的application/x-www-form-urlencoded,不受网页的表单约束，使用JSON,这个是构建REST API的一个常见选择；
sqlx::query_as!()将检索到的行，映射到其第一个参数中指定的类型；
--------------------------------------------------------------------------------------------------------------------------------------------
9.7 with_context()与context()相近，将Result的错误变体转换为anyhow::Error,同时用上下文信息来填充它，但with_context()是惰性的；使用context()每次发送
邮件是都分配这个字符串，相反，使用with_context()只有在发送邮件失败时才会调用闭包；
---------------------------------------------------------------------------------------------------------------------------------------------
9.8 query!: 用于临时性查询或返回的列不适合映射到现有结构体的情况。它会在编译时检查查询并生成一个匿名记录结构体;query_as!: 用于将查询结果映射到预定义的、
明确命名的结构体,这更有利于代码的组织、复用和文档化，尤其是在处理多个返回列或复杂查询时;

数据的一致性：假设软件永不变化，这个推理是合理的。但是，我们正在为高频部署进行优化，存储在Postgres实例中的数据，在应用程序的新旧版本之间产生了时间上的耦合。
我们从数据中查询到的邮件被应用程序的前一个版本标记为有效，而在当前的版本中可能无效；

保证数据的一致性：我们需要基于领域的要求，根据具体的情况来评估这个问题。有时，处理无效的记录是不可接受的---程序应该失败，操作人员必须介入纠正无效的记录；有时
，我们需要处理所有的历史记录(如分析)，并且应该对数据做出最小的假设---字符串是最安全的方式。在我们的例子中，可以进行折中：在获取下一期邮件简报的收件人名单时，
跳过无效的邮件。针对每个无效地址发出警告，允许操作人员发现问题，并在未来的某个时间点纠正错误的记录。实现方式：使用filter_map();
-----------------------------------------------------------------------------------------------------------------------------------------------
9.8.1 责任界限：业务层面的决定，最好放在业务层面，get_confrimed_subscriber()应该只存在存储层和领域层之间充当一个适配器，它处理数据库特定的部分(即查询)
和逻辑映射，但在映射或查询失败时将处理的决定权交给调用者;

Err(anyhow::anyhow!(error)): 使用 anyhow! 宏将原始的、特定的错误 error 包装成一个新的、类型擦除的 anyhow::Error。然后将其包装在 Err() 中。
tracing::warn!(error.cause_chain = ?error, "some message"):这段是tracing 宏的高级用法，日志级别: warn! - 错误级别宏,字段赋值: field_name = expression,
格式化符号: ? 或 % 前缀(?调试格式化操作符,% 操作符-显示格式),消息模板: 字符串字面值,
-------------------------------------------------------------------------------------------------------------------------------------------------
9.8.3 get_confrimed_subscriber() 中定义的结构体并未增加任何价值，无法从使用专门的类型表示返回的数据中收益；
--------------------------------------------------------------------------------------------------------------------------------------------------
10.1.2 身份认证，用户密码被暴力破解、手机丢失被冒用、指纹被伪造等都有不足，将他们结合起来，几乎就是多因素身份验证：它需要用户提供至少两种不同类型的认证因素才可
获得访问权限；
--------------------------------------------------------------------------------------------------------------------------------------------------
10.2.1 基于密码的身份验证：API必须在请求头中传入Authorization字段，即Authorization: Basic <编码后的凭据>，编码后的凭据，是{username}:{password}的base64编码格式，
根据规范，我们需要将API分成保护空间或领域---对同一个领域内的资源使用相同的身份验证方案和凭据集。
我们只有POST /newsletters一个需要保护的端点，因此有一个名为publish的领域。API必须拒绝所有缺少该请求头或使用无效凭据的请求；
---------------------------------------------------------------------------------------------------------------------------------------------------
10.2.1.1 提取凭据，实现了拥有用户名和密码才能访问 /newsletters 端点
----------------------------------------------------------------------------------------------------------------------------------------------------
10.2.2 接受随机凭据的认证层并不理想，我们需要开始验证从Authorization请求头中提取的凭据，然后与已知的用户列表进行比较；
查询数据库时用到的 r#" ... "# : 这是 Rust 的原始字符串字面量语法；
tracing crate 实现动态记录字段值；
-----------------------------------------------------------------------------------------------------------------------------------------------------
10.2.3.2 保护密码的安全性：存储密码是为了每次进行相等性检查，如果只关心相等性，依据"所有确定性函数在给定相同的输入时都会返回相同的输出"策略，反其道而行：
psw_condidate != stored_psw, 若f(psw_input) == f(stored_psw) ,避免存储原始密码；

加强版：两个输入x和y之间的相似程度应该与相应的输出f(x)和f(y)之间的相似程度不存在任何关系，需要一个加密的哈希函数，哈希函数将输入空间中的字符串映射到固定长度的输出；加密，是指函数的附加属性，也被称为“雪崩效应”，即输入的微小差异会导致输出的巨大差异，以至于看起来不相关；
但需要注意：哈希函数不是单射的，存在微小的碰撞风险---如果f(x)=f(y),则x==y的可能性很高(但不是100%)；

数据库的表中存储密码可以是二进制类型，或者使用十六进制格式，将Digest::digest()返回的字节编码成字符串；
-------------------------------------------------------------------------------------------------------------------------------------------------------
10.2.3.3 原像攻击：即攻击者获取到了user表，他们只需找到一个输入字符串s,使其SHA3-256哈希值与试图破解的密码匹配一致---换句话说找到一个碰撞，这被称为原像攻击；
    如果n>128,则认为是不可能的破解，除非SHA-3中发现漏洞，否则不用担心针对SHA3-256的原像攻击。
-------------------------------------------------------------------------------------------------------------------------------------------------------
10.2.3.4 简答字典攻击：对原始密码进行一些假设来减少搜索空间，如密码长度是多少、使用了哪些符号，这种方式也难以破解；
字典攻击：从过去十年的众多安全漏洞中找到一个密码数据库，然后预先计算出常用的1000万个密码的sha3-256哈希值，再扫描我们的数据库，寻找匹配的密码，这种方式很有效；
到目前为止，我们提供的所有加密哈希函数都被设计的非常快，快到足以上任何人在不使用专用硬件的情况下完成字典攻击；
因此，我们需要一种速度更慢，但与加密哈希函数具有相同数学特性的函数；
--------------------------------------------------------------------------------------------------------------------------------------------------------
10.2.3.6 开放式Web应用程序安全项目(OWASP)通常是一个关于网络安全的宝库，提供了有关安全密码存储的有用指导，以及大量优质的教育资料。Argon2、bcrypt、scrypt、PBKDF2都
被设计成计算密集型的，它们还公开了配置参数，以进一步减慢哈希值计算的速度：应用程序开发人员可以调整一些参数以跟上硬件加速，而无须每个几年就迁移到新的算法。

我们采用OWASP的建议将SHA-3替换为Argon2id.Rust Crypto组织为我们提供了一个纯Rust实现的argon2.

argon2的详细介绍
----------------------------------------------------------------------------------------------------------------------------------------------------------
10.2.3.7 盐值---Argon2比SHA-3慢的多，但不足以是字典攻击成为不可能，但是如果攻击者必须对数据库中的每个用户重新计算全部字典的哈希值，那么就变得困难的多，这就是盐值的作用。对于每个用户，生成一个唯一的随机字符串---盐值。在生成哈希值之前，将盐值添加到用户密码的前面。PasswordHasher::hash_password()处理了添加盐值的业务。盐值和密码哈希值一起被存储在数据库中。

如果攻击者获取到数据库备份，他们将能够轻松访问盐值，就是为什么OWASP建议使用额外的防御层---撒盐(peppering),被存储在数据库中的所有哈希值都使用一个只有应用程序知道的共享秘钥进行加密。然而加密也带来了一系列挑战：将秘钥存储在哪里？如何进行秘钥轮换。答案通常设计硬件安全模块或秘钥保管库。
----------------------------------------------------------------------------------------------------------------------------------------------------------
10.2.3.8 PHC字符串格式提供了密码哈希值的标准表示方式，包括哈希值本身、盐值、算法以及其它关联的参数，比base64编码更好的方案；
为了对用户进行身份验证，我们需要可重复性：每次都必须运行完全相同的哈希算法。
base64编码存储的哈希值，带有强烈的隐含假设：在password_hash列中存储的所有值都是使用相同的负载参数计算得出的。为了安全，迁移到更高的负载参数上时，为了继续对老用户进行身份验证，那我们必须在每个哈希值旁边存储用于计算它的负载参数。如果Argon2id存在漏洞，被迫迁移到其他算法，将会很繁琐。
更好的解决方案是PHC字符串格式。PHC字符串格式提供了密码哈希值的标准表示方式，包括哈希值本身、盐值、算法以及其它关联的参数。
argon2包暴漏了PasswordHash::new()，它是HPC字符串格式的Rust实现。
---------------------------------------------------------------------------------------------------------------------------------------------------------
10.2.4 不要阻塞异步执行器
TEST_LOG=true cargo test --quiet --release newsletters_are_delivered_to_confirmed_subscribers | grep "VERIFY PASSWOED" | bunyan   未看到结果
TEST_LOG=true cargo test --quiet --release newsletters_are_delivered_to_confirmed_subscribers | grep "VERIFY PASSWOED HASH" | bunyan  未看到结果
TEST_LOG=true cargo test --quiet --release newsletters_are_delivered_to_confirmed_subscribers | bunyan 可看到结果，由个人计算，差12ms

***重点***
在Rust中，async/await是基于一种被称为“协作式调度”的概念构建的；.await被称为交还点---future从前一个.await进展到下一个.await，然后将控制权交还给执行器。
执行器可以选择重新对同一个futrue进行轮询，或者优先处理其它任务以取得进展。
异步运行时的基本假设是：大多数异步任务都在执行某种输入输出(I/O)工作---它们的大部分执行时间都花费在等待其他事件的发生上。
轮询poll应该是快速的---它应该在**10~100μs微妙**内返回；如果调用poll的时间较长(或永远不返回)，那么异步执行器将无法在任何其他任何上取得进展---这就是
我们所说的“任务阻塞了执行器/异步线程”的情况；应该始终注意那些可能需要**超过1ms毫秒**的CPU密集型工作负责；
为了与tokio友好的协作，我们必须使用tokio::task::spawn_blocking将执行超过1ms的CPU密集型任务转移到一个单独的线程池中，这些线程专门用于阻塞操作，并不干扰异步任务的调度；
***重点***
一个异步任务在每次 await 之前，连续执行同步代码（不包含 .await）的时间应该尽可能短，理想情况下不超过 10-100 微秒（μs），绝对不要超过 1 毫秒（ms）;

tracing::Span::current(),返回当前跨度，实际指的是“当前线程的活跃跨度”，tracing::info_span!(...) 在创建新 Span 时，会默认地、自动地
尝试将自己设置为 Span::current() 的子跨度；对新线程创建有关联的跨度，可以通过显式的将当前跨度添加到新创建的线程来解决问题，即current_span.in_scope(|| {})。
------------------------------------------------------------------------------------------------------------------------------------------------------------
10.2.5 
TEST_LOG=true cargo test --quiet --release non_existing_user_is_rejected | grep "HTTP REQUEST" | bunyan  测试耗时55ms和书本1ms结果不一致
TEST_LOG=true cargo test --quiet --release invalid_password_is_rejected | grep "HTTP REQUEST" | bunyan   测试耗时165ms和书本10ms结果不一致
用户不存在和错误密码的测试耗时，存在较大差距，攻击者可以利用这个差异进行时序攻击，它属于侧信道攻击的一大类。
如果攻击者至少知道一个有效的用户名，那么他们可以通过检查服务器的响应时间来确认是否存在另一个用户名 --- 用户枚举漏洞
防止时序攻击的策略方式：
    一.消除密码验证失败和用户名验证失败之间的时间差异；
    二.限制给定IP地址/用户名的身份验证失败尝试次数，通常对抵御暴力破解很有价值；

实现策略一：需要阻止其过早退出---应该有一个预期的回退密码(带有盐值和加载参数)，它先根据username获取存储的password_hash和user_id的情况决定其值,再与密码候选集和哈希值进行比较,
最后必须再检查user_id是否存在。
----------------------------------------------------------------------------------------------------------------------------------------------------------------
10.3  10.2.5中基本验证方案是在客户端和服务器之间传递凭据---用户名和密码被编码，但没有被加密。我们必须使用传输层安全(TLS)来确保没有人能窃听到客户端和服务器之间的流量，从而破坏
用户凭据，如中间人攻击(这就是为什么绝对不应该在没有使用HTTPS(即HTTP+TLS)的网站上输入密码)，我们的API运行在HTTPS上，所以这里没有什么要做的；
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
10.3.3 目前为止，我们对谁在调用API还相当模糊，我们需要支持的交互类型是身份验证的关键决定因素；
我们将研究三种调用者的类别：
    1.其他API(机器对机器);
    2.使用浏览器的用户;
    3.代表人的另一个API;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
10.3.4  机器对机器
在微服务架构中，这种情况会经常发生
在一个组织内部的微服务生态系统中，所有服务都由同一组织拥有时，一种常见的选择是使用双向TLS(mTLS) ；
签名和mTLS都依赖公钥加密---必须对秘钥进行配置、轮换和管理，只有在系统达到一定的规模后，才能合理的进行这些操作；
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
10.3.4.1 使用OAuth 2的客户端凭据，一种专门为机器对机器通信设计的授权模式，无用户参与
API不再需要管理密码(在OAuth 2的属于中被称为"客户端秘钥")，---这个问题被委托给了集中式的授权服务器；
调用者通过授权服务器进行身份验证---如果成功，授权服务器会授予他们一组临时凭据(JWT访问令牌)，用于调用API；
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
10.3.5  使用浏览器的用户
基本身份验证要求客户端在每个请求中都提供凭据，假设我们有了一个受保护的端点，但如果有5个或10个需要权限的页面，基本身份验证都将强制用户在每个页面上提交他们的凭据，这不好。
我们需要一种记录用户几分钟前已经通过身份验证的方式---将某种状态添加到来自同一浏览器的请求序列中，这可以通过会话实现；
用户被要求通过登录页面进行一次身份验证，如果成功，服务器会生成一个一次性秘钥，即经过身份验证的会话令牌。该令牌被以安全的Cookie的形式存储在浏览器中。这种方式通常被称为："基于会话的身份验证"
------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.3.5.1 联合身份
使用基于会话的身份验证，仍然有一个身份验证步骤需要处理---登录表单；
联合身份认证是使用其他账号进行登录，将身份验证步骤委托给第三方，只给我们共享必要的信息，该实现依赖openID，这是基于OAuth 2标准的身份层；
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.3.6  机器对机器(机器代表人) ，即人授权机器(例如第三方服务)执行对API的操作，在这种情况下，第三方服务不能被单独授权执行任何针对API的操作。只有用户授予了第三方服务访问权限，限定
在其权限集合访问内，第三方服务才能对API执行操作， 是不同于 纯粹的机器对机器身份验证；
这是OAuth 2的典型场景---第三方永远不会看到我们的用户名和密码，它们从认证服务器接收到一个不透明的访问令牌，我们的API知道如何检查该令牌以授予(或拒绝)访问权限；
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.4  浏览器是我们的主要目标，我们的身份验证策略需要相应的做出更新；
首先将基于身份验证流程转换为基于会话的身份验证的登录表单
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.5.1 提供HTML页面---处理登录表单的HTML页面和请求体提交
明确内容类型：HTML mete标签 或Content-Type
将信息嵌入文档中，对于浏览器和机器人爬虫识别内容非常有效，而Content-Type的HTTP请求头会被所有HTML客户端理解，而不仅仅是浏览器；
返回HTML页面时，内容类型应该被设置为"text/html;charset=utf-8"；
浏览器或客户端完全依赖 Content-Type 头来决定如何处理响应体
HTTP 响应的内容类型：
    1.文本（Text）
    用于传输文本内容，通常可以指定字符集
        - text/html： 最常用的格式，用于返回 HTML 页面
        - text/plain: 普通文本，浏览器不会解析为其以外的格式
        - text/css： CSS 样式表
        - text/csv： 逗号分隔值文件
        - text/javascript： 已过时，但仍有使用。现代标准使用 application/javascript
    2.应用（Application）
    用于传输二进制数据或应用程序特有的数据
        - application/json： 现代 API 最常用的格式，用于传输结构化数据
        - application/xml： XML 数据
        - application/octet-stream： 通用的二进制数据流。浏览器会将其视为需要下载的附件
        - application/pdf： PDF 文件
        - application/zip： ZIP 压缩文件
        - application/x-www-form-urlencoded： 表单默认的提交编码格式
        - multipart/form-data： 表单中包含文件上传时的提交编码格式
    3.图像（Image）
    用于传输图像文件
        - image/jpeg： JPEG 图像
        ... 
        等等
    4. 音频（Audio）
    用于传输音频文件
        - audio/mpeg： MP3 音频
        ...
        等等
    5. 视频（Video）
    用于传输视频文件
    ...
    等等
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6 登录 http://localhost:8000
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.1 HTML表单,第一种html代码，使用GET提交到/login,请求中不包含请求体，所有参数通过 URL 传递(会在地址栏显示)，所有输入数据以明文形式编码为查询参数;
第二种添加form明确的设置action和method，使用POST提交到/login,使用请求体将输入数据传递到后端。这样更安全！


HTML代码介绍：使用'input'元素定义 数据字段，'input'元素使用type属性告诉浏览器如何显示他们；
<form action="/login" method="post"> :通过在form上明确设置action和method的值,更安全；
GET - 读取,作用：从服务器获取资源。请求中不应包含请求体，所有参数都应通过 URL 传递;
POST - 创建,作用：向指定的 URI（统一资源标识符）提交数据，服务器会根据请求体中的数据创建一个新的资源;
PUT - 替换式更新,作用：客户端提供资源的完整表示，用于替换目标 URI 下的整个资源。如果资源不存在，则创建它
DELETE - 删除,作用：请求服务器删除指定的资源;
http://localhost:8000/login
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.2  登录成功后的重定向；重定向表示需要客户端采取进一步的操作才能完成请求；

重定向响应需要两个元素：
    - 一个重定向状态码；
    - 一个Location头，设置为要重定向到的URL;
所有的重定向状态码都在3xx范围内，需要根据HTTP请求方法和语义选择最合适的一个(例如:是临时重定向还是永久重定向)；
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.3 处理表单数据

我们不是登录成功后才需要重定向，而是总是需要重定向；
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.3.1 重构authentication模块，能同时在POST /login和Post /newsletter中使用；
新定义的AuthError类型,实现到publishError的转换：调用map_err在内联(闭包)中执行映射操作；
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.3.2 拒绝无效的凭据

303 明确要求客户端将请求方法转换为 GET 进行重定向,这非常适合在 POST 请求（如表单提交）处理后使用，以避免刷新页面时重复提交
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4 上下文错误； 让错误消息出现在登录表单的顶部，为用户提供信息的同时允许他们快速重试；

10.6.4.1 最简单的方法
在从ResponseError返回登录的HTML页面中插入一个额外的段落(<p> HTML元素),
其缺点：一、2个几乎相似的登录界面，在不同的地方定义；
       二、失败后刷新，提示用户是否重新提交表单；
改进：通过另一个种重定向来实现---如果身份验证失败，则将用户送回到GET /login;

详解 impl ResponseError for LoginError
    - ResponseError：这是 Rust Web 框架（如 Actix-Web）中一个关键的 trait（接口）。它定义了如何将一个错误类型转换为一个 HTTP 响应；
    - LoginError：这表示我们正在为自定义的 LoginError 类型实现这个 trait。LoginError 可能是一个枚举（Enum），列举了各种登录相关的错误；
实现了 ResponseError trait 后，在任何返回 Result<T, LoginError> 的请求处理函数（handler）中，如果结果是 Err(LoginError)，Actix-Web 框架
会自动调用这里的 error_response 方法来生成并发送 HTTP 响应；
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.2  LOCATION请求头的值确定了用户被重定向到的URL,还可以指定查询参数；查询参数是URL的一部分；

访问流程：
浏览器输入"localhost:8000/login"-> Request使用HTTP GET /login_form 访问服务器 -> 获得HTML页面
由于HTML中form明确的设置action和method,提交form 后 -> Request使用HTTP POST /login 访问服务
凭据验证失败后，Post.rs中的error_response()会重定向到"HTTP GET /login_form ，并且URL包含error查询参数
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.3  跨站脚本攻击(XSS)，即攻击者利用由不受信任的来源构建的动态内容，将HTML片段或JS代码片段注入可信任的网站中；
<p><i>{error_message}</i></p>" 是在HTML中显示不受信任的数据(查询参数的值)
查询参数不是私密的，后端服务无法阻止用户调整URL,因此可能被人篡改；攻击者篡改URL连接包含的查询参数后给用户，引导用户填写个人信息，链接到一个由攻击者控制的网站；

OWASP提供了一份详尽的防止XSS攻击的指南；开发Web应用程序，强烈建议熟悉它；根据OWASP指南，必须对不受信任的输入进行HTML实体编码；HTML实体编码通过转移HTML元素的字符，来防止插入其它HTML元素；
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.4 消息认证码，是一种机制来验证查询参数是否由应用程序接口设置，以及是否被第三方修改过，是比字符转移更强大的防护措施；
消息认证，他能保证消息在传输过程中未被修改(完整性)，还能验证发送者身份(数据来源验证)；
消息认证码MAC，是在消息中添加一个标签，让验证者可以检查消息的完整性和来源；
HMAC是基于哈希的消息认证码

消息标签：在信息中加入密钥，并将所得到的字符串输入哈希函数中，然后，将哈希结果与密钥连接，并再次进行哈希处理，这里的输出结果就是消息标签；
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.5 添加HMAC标签 

actix_web::error::InternalError:将底层错误转换为特定的HTTP响应状态码，保留原始错误信息的同时改变响应行为，提供一致的方式来处理不同类型的错误
InternalError可以由HttpResponse和错误构建，它可以作为请求处理函数的错误返回类型(它实现了ResponseError),并向调用者返回传递给构造函数的HttpResponse;
这种设计使得开发者能够在不丢失原始错误信息的前提下，为不同的业务场景提供恰当的HTTP响应;

在应用程序状态中，使用Secret(String)注册某个状态(例如HMAC密钥)，存在重复的风险，也就是说，另一个中间件或服务可能会针对应用程序状态注册另外一个Secret<String>,从而覆盖HMAC密钥(或反之亦然)，
最好是创建一个包装类型绕开这个问题；
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.6 在GET /login 中验证HMAC标签，我们使用查询参数传递错误消息，可能没有错误，或有错误并期望同时看到error和tag查询参数；
验证标签失败，我们选择将验证失败记录为警告，并在渲染HTML页面时跳过错误消息。使用不可靠的查询参数重定向的用户将会看到登录页面，这种情况可以接受；

可疑的URL:
http://localhost:8000/login?error=Your%20account%20has%20been%20locked%2C%20please%20submut%20your%20details%20%3Ca%20href%3D%22https%3A%2F%2Fzero2prod.com%22%3Ehere%3C%2Fa%3E%20to%20resolve%20the%20issue

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.7  使用查询参数传递错误消息，查询参数也是URL的一部分，因此会被存储在浏览器的历史记录中，同样有效的tag也会有被记录；因此希望错误消息是临时的，它会在尝试登录失败后显示，但不会被
存储在浏览器的历史记录中，而再次触发错误消息的唯一方式，应该是再次登录失败；需要使用Cookie;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.8 Cookie是服务器发送给 '用户所使用的' 浏览器的小型数据；
所有错误相关的信息都通过一个辅助渠道(Cookie)进行交换，其对浏览器历史记录是不可见的；
"消息闪现"技术：将错误消息呈现时，Cookie被消耗掉，如果URL重新加载，错误消息将不会再次显示;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.9 设置Cookie实际上是通过在相应中添加一个特殊的HTTP请求头Set-Cookie来设置Cookie: Set-Cookie: <cookie-name>=<cookie-value>;
Set-Cookie可以被多次指定---每个Cookie都可以设置一次；
Cookie是如此普遍，值得拥有一个专门的API,让我们免去使用原始请求头的痛苦。reqwest将此功能锁定在cookies功能标志的后面；
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.10 在actix-web中设置Cookie
.insert_header(("Set-Cookie", format!("_flash={e}")))
或 .cookie(Cookie::new("_flash", e.to_string()))    actix-web提供的一个专门的Cookie API
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.11 将true传递给reqwest::ClientBuilder::cookie_store，代替浏览器 Get /login时带上Cookie;
注意:如果希望Cookie传递正常，则必须对所有的API请求使用相同的reqwest::Client实例；
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.12 使用HttpRequest::cookie根据名称检索Cookie
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.13 在actix-web中删除Cookie
如果登录失败后，刷新页面，错误消息仍然存在；但错误消息应该是临时的，需要从用户的浏览器中删除 _flash Cookie;

持久化方面，有两种类型的Cookie：会话Cookie和持久Cookie。会话Cookie被存储在内存中---当会话结束时(即浏览器关闭了)，它们会被删除。
相反，持久Cookie被保存在磁盘上，当重新打开浏览器时它们仍然存在；

一个普通的Set-Cookie请求头创建一个会话Cookie。要设置一个持久Cookie，必须使用Cookie属性---可以是Max-Age或Expires,指定一个过期策略;
Max-Age是Cookie过期前剩余的秒数，Set-Cookie:_flash=omg;Max-Age=5会创建一个持久的 _flash Cookie，它将在接下来的5s内有效。Max-Age=0，
则指示浏览器立即使Cookie过期；add_removal_cookie()该方法设置需移除的Cookie属性,使浏览器/客户端删除具有此名称的存储Cookie，但不需要
设置Max-Age=0;
Expires则需要一个日期，Set-Cookie:_flash=omg;Expires=Thu,31 Dec 2022 23:59:59GMT,会创建一个在2022年年底之前有效的持久Cookie;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.14 Cookie的安全性
通过不安全的连接(使用的是HTTP,而不是HTTPS)传输Cookie导致容易受到中间人攻击；
第一道防线是API---应该拒绝在未加密的通道上传输的请求，通过将新创建的Cookie标记为Secure,告诉浏览器只能通过安全连接传输的请求中添加Cookie;
第二个主要威胁是JavaScript；客户端运行的脚本可与Cookie存储进行交互，作为一个经验法则：除非有充分的理由，否则Cookie对脚本应该是不可见的。将
新创建的Cookie标记为Http-Only,把它们隐藏起来，不让客户端看到---浏览器可以正常访问，但脚本将无法看到它们；即使这样，JavaScript也可能覆盖它们并
欺骗后端执行一些意外的操作；

带有HMAC标签的Cookie值，通常被称为"签名Cookie",通过后端验证标签，可以确保签名Cookie的值没有被篡改；
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.6.4.15 actix-web-flash-messages crate,提供了一个框架，用于处理actix-web中处理闪现(临时)消息
actix-web-flash-messages提供了一个基于Cookie的实现，即CookieMessageStore;
IncomingFlashMessage:无论检索所传入的闪现消息，还是确保在读取后将其清除,actix-web-flash-message会处理这些事，再调用请求处理函数之前，还会在后台验证Cookie签名的有效性
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.7.4 actx-session为actix-web提供会话管理,其中关键类型SessionMiddleware，负责加载会话数据、跟踪状态的变化、并在请求/响应生命周期结束时将其持久化,在存储方面，可以选择通过
实现SessionStore trait进行定制化，或者 打开其开箱即用的特性，包括Redis后端(RedisSessionStore类型)，新建RedisSessionStore实例，必须传递一个Redis连接字符串作为输入；

anyhow::Error通用错误类型,错误类型擦除：可以包装任何实现了 std::error::Error trait 的错误类型
当方法由同步变为异步时，返回错误类型std::io::Error变更为Result<Self, anyhow::Error>，同时main函数中返回的错误类型由std::io::Error变为anyhow::Result<()>;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.7.4.1 在开发环境中配置Redis

我们需要在持续集成流水线中与Postgres容器一起运行一个Redis容器---查看更新后的YAML文件；
还需要在开发机器上运行一个Redis容器来执行测试套件和启动应用程序；
chmod +x ./scripts/init_redis.sh  :  +x 添加执行权限；
init_redis.sh脚本中，Fi应该是fi，书本源代码错误；
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.7.4.2 在DigitalOcean上配置Redis
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.7.5 为新的界面创建一个管理仪表盘
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.7.5.1 登录成功后重定向
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.7.5.2 会话
在 HTTP 这个无状态协议中，会话是一种在服务器端保持用户状态信息的机制，实现方式： 服务器在用户第一次访问时，会创建一个唯一的 Session ID，并通过 Cookie 发送给浏览器。浏览器在后续的每次请求中都会自动带上这个 Cookie。服务器通过 Cookie 中的 Session ID 来找到对应的“数据存储柜”（会话状态）；

将在login中把用户标识符存储到会话状态中，然后在admin_dashboard的会话状态中获取它；
Session是actix_session中的第二种关键类型；SessionMiddleware完成了检查传入请求中的会话Cookie的所有繁重工作---如果有的话，就从存储后端加载相应的会话状态，否则新建一个空的会话状态；Session作为
提取器，在请求处理函数中与该状态进行交互；
在处理函数返回响应后，SessionMiddleware会检查Session的内存状态---如果有变化，它将调用Redis更新该状态，如果没有会话Cookie，他还将负责在客户端设置一个会话Cookie;

一个具体的用户场景的整个流程：
用户登录：
    - 用户提交登录表单。
    - login 处理函数验证凭据成功后，通过 session.insert("user_id", ...) 将用户ID存入会话。
    - SessionMiddleware 检测到变化，将这个 {"user_id": ...} 状态保存到 Redis，并在响应中设置会话 Cookie。
访问管理员页面：
    - 用户点击进入 /admin。
    - 浏览器自动在请求中带上会话 Cookie。
    - SessionMiddleware 通过 Cookie 中的 Session ID 从 Redis 加载出 {"user_id": ...} 状态。
    - admin_dashboard 处理函数通过 session.get("user_id") 成功读取到用户ID，并显示仪表板。
这个模式是构建有状态 Web 应用（尤其是需要用户认证的应用）的基石，它安全、高效且对开发者友好。

登录流程有可能受到会话固定攻击的影响---会话可用于认证用户以外的其它用途：例如，在访客模式下购物时，跟踪哪些物品已被添加到购物车中。这意味着用户可能与匿名会话相关，而在他们通过认证后，又与特权会话相关。这一点可以被攻击者所利用；

另一种攻击策略---在用户登录之前，在他们的浏览器中植入一个已知的会话令牌，等待认证发生，然后成功了！这就是所谓的攻击！可采取一种简单的策略来破坏这种攻击---在用户登录时轮换会话令牌；这是一种普遍的做法，
所有主流web框架的会话管理API都支持它，包括actix-session,通过Session::renew;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.7.5.3 Session的类型接口 (为何这样做的原因没看明白)
Session是强大的，但仅将其作为基础来构建应用程序状态处理时，它是脆弱的；当系统演进迭代时，如何确保更新了所有路由？如何防止因打字错误而引起生产故障？可以使用类型系统彻底解决问题，我们将在Session之上
构建一个强类型的API来访问和修改状态---在请求处理函数中不再有字符串键和类型转换。

让TypedSession本身成为一个actix-web提取器；
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.7.5.4 拒绝未认证的用户
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.8 种子用户---数据库中没有用户，也没有管理员的注册流程。也就是说，应用程序的拥有者会以某种方式成为邮件简报的第一个管理员；
将创建一个种子用户---通过迁移，在首次部署应用程序时，在数据库中创建一个用户。种子用户将有一个预先确定的用户名和密码；在第一次登录后，他们能够修改密码。

种子管理员有能力邀请更多的人；
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.8.1 数据库迁移 ---设置种子用户---预先确定的用户名和密码
cargo test -- --nocapture
admin everythinghastostartsomewhere

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.8.2 密码重置
用一个已知的用户名和密码组合配置一个特权用户，这比较危险，需要让种子用户能够修改自己的密码；
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.8.2.1 表单骨架
我们先把所需的脚手架准备好。这是一个基于表单的流程，与登录流程一样，需要一个GET端点来返回HTML表单，一个POST端点来处理提交的信息;

脚手架是指预先构建好的基础代码结构或框架，它提供了:
    - 项目的基本目录结构
    - 必要的配置文件
    - 基础代码模板
    - 常用的功能模块

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.8.2.2 异常流程：新密码不匹配
系统要求用户输入两次新的密码，但两次输入不一样。此时希望将用户重定向到带有错误信息的表单；

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.8.2.3 异常流程：当前密码失效
要求用户在表单中提供当前密码，这是为了防止攻击者设法获得有效的会话令牌，从而把合法用户锁定在其账户之外；

