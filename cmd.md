sqlx-cli工具：
only for Postgres:
    cargo install sqlx-cli --no-default-features --features native-tls,postgres
----------------------------------------------------------------------------------------

.env文件的意义：
# sqlx在编译时与Postgres进行交互，已检查查询是否合法，
# 但依赖DATABASE_URL环境变量确认数据库的位置。
# sqlx将从.env文件中读取DATABASE_URL,省去了每次都要重新导出环境变量的麻烦。
# .env文件 仅与 开发过程、构建和测试步骤相关。
-----------------------------------------------------------------------------------------

curl http://127.0.0.1:8000/health_check -v

curl -i -X POST -d 'email=thomas_maiinn%40hostmail.con&name=Toiim' http://127.0.0.1:8000/subscriptions

-----------------------------------------------------------------------------------------
docker build --tag zero2prod --file Dockerfile .

----------------------------------------------------------------------------------------------
sqlx 的"offline"离线模式：
    cargo sqlx preare -- --lib
    prepare执行的与调用cargo build是所做的工作类似,它将这些查询的结果保存在一个元数据文件(sqlx-data.json)中，由sqlx自行检测，可以完全跳过查询，从而执行离线构建。
    --lib, 由于所有的SQL查询都被放在以'lib.rs'为根的模块中，因此这里必须要用参数指明命令作用于lib部分。

------------------------------------------------------------------------------------------------

使用环境变量注入机密信息：例如数据库root用户的用户名和密码

-------------------------------------------------------------------------------------------------
serde-aux crate从环境变量中提取整数
--------------------------------------------------------------------------------------------------
生成环境中，与数据库通信提供加密通信，即SSL模式
-----------------------------------------------------------------------------------------------
利用Rust的类型系统完全消除输入数据的无效性
------------------------------------------------------------------------------------------------
实现AsRef<str>， 方可使用as_ref()
------------------------------------------------------------------------------------------------
? 运算符的语法糖：let Err(err) = 函数名(){ ... return Err(error)}; ? 只能在返回Result的函数中使用
------------------------------------------------------------------------------------------------
validator crate 验证email格式是否有效
------------------------------------------------------------------------------------------------
属性测试：fake crate提供基本数据类型和高级对象(IP地址、国家代码等)的生成逻辑，尤其是电子邮件，即生成随机测试数据
-----------------------------------------------------------------------------------------------
两个主流的属性测试工具：quickcheck和proptest；cargo test valid_emails -- --nocapture查看有效的电子邮件地址
-------------------------------------------------------------------------------------------------------
N实现TryFrom<T> 后，使用T.try_into()可返回N类型（将T类型转换为N类型）；两种类型之间是可能会失败的转换，会消耗输入的值,
---------------------------------------------------------------------------------------------------------
cargo check --all-targets
---------------------------------------------------------------------------------------------------------
如何测试REST客户端:用wiremock模拟服务器进行单元测试，使用fake()生成随机数据（明确不关注输入，他们的值不影响测试的结果）
------------------------------------------------------------------------------------------------------------
json方法会将Content-Type头设置为application/json
------------------------------------------------------------------------------------------------------------
添加授权令牌，Client使用header()设置授权请求头
--------------------------------------------------------------------------------------------------------------
7.2.5使用wiremock提供的匹配器matchers验证请求头(header)、请求端点(path)、请求方法(method)以及header_exists，而，
验证请求体则需要自己实现Match trait,且字段名称必须采用帕斯卡命名法#[serde(rename_all = "PascalCase")]
-------------------------------------------------------------------------------------------------------------------
7.2.5.1 字符串切片&str只是指向其他对象所拥有的内存缓存区的指针;在结构体中存储引用，需添加一个生命周期参数，
确保引用不会比指向的内存缓冲区存在更长的时间；
-------------------------------------------------------------------------------------------------------------------
7.2.6.1 reqwest::Client::send()方法只要获得服务器响应，不管状态码如何，就返回Ok！Response::error_for_status()对服务器返回错误，
则将响应转换为错误
--------------------------------------------------------------------------------------------------------------------
7.2.6.2一个经验法则：每当进行I/O操作时，都要设置超时时间！如果服务器的响应时间超过超时时间，则应该失败并返回错误;
--------------------------------------------------------------------------------------------------------------------
7.2.6.3重构测试辅助函数
--------------------------------------------------------------------------------------------------------------------
7.2.6.4reqwest的Client超时时间设置为可配置,默认1000毫秒
------------------------------------------------------------------------------------------------------------------
7.3.7利用了tests文件下的每个文件都是独立的可执行文件的优势,分解为更小且更易管理的模块; cargo build --tests; ls target/debug/deps | grep api;
---------------------------------------------------------------------------------------------------------------------
7.3.8.2-1提取启动代码，在启动逻辑中添加测试触发器，实现函数化代码
---------------------------------------------------------------------------------------------------------------------
7.3.9我们需要小心，不要把客户端逻辑分散在整个测试套件中(当API发生变化时，我们不想在数十个测试中去除某个端点路径末尾的s)
---------------------------------------------------------------------------------------------------------------------
7.6.3在线部署软件新版本，得先修改数据库模式，再部署软件新版本；对数据库的做法：对于新的必填地段，第1步：以非必填的形式添加字段后，原版本应能正常运行；
第2步：新版本部署到生产环境中；第3步：先对历史记录回填，然后才能修改这个字段的属性；第4步：运行测试用例，然后部署生产数据库；
------------------------------------------------------------------------------------------------------------------------
7.6.5部署新版本的软件，添加新表，可以直接添加，而原有的应用程序会忽略这个表；
-------------------------------------------------------------------------------------------------------------------------
7.7.2 linkify可以从请求中提取body里的链接
-------------------------------------------------------------------------------------------------------------------------
7.7.4 参数类型web:Query<Parameters> 仅在成功提取查询参数的情况下，调用处理函数；提取失败，返回400
-------------------------------------------------------------------------------------------------------------------------
7.7.5.2 对于域名和协议，将根据应用程序运行的环境来确定：在测试环境中应该是http://127.0.0.1,在生产环境中应该是一条使用HTTPS的DNS记录；
---------------------------------------------------------------------------------------------------------------------------
7.7.5.3 重构集成测试
--------------------------------------------------------------------------------------------------------------------------
7.7.6.2 订阅令牌
--------------------------------------------------------------------------------------------------------------------------
7.8.1 应用程序中，当数据库对多表同时进行多种操作时，若出错，难以理清数据库可能的状态；事务，是一种将多个有关联的操作组合在一起的方法，
使他们成为一个基本执行单位，数据库保证事务中的所有操作要么全部成功，要么全部失败；BEGIN语句后的所有查询都会成为事务的一部分，
事务以COMMIT语句结束；事务中任何一个操作失败，数据库都将回滚；
-----------------------------------------------------------------------------------------------------------------------------
7.8.3 如果不提交事务，则必定回滚；Transaction::commit用于提交改动，Transaction::rollback用于回滚整个操作；
-----------------------------------------------------------------------------------------------------------------------------
8.2 错误类型应当携带失败场景的上下文，并以此发布一个日志事件，为操作人员提供细节足够多的报告，使其得以发现并解决问题；对于系统内部错误，
我们利用类型、方法、字段提供相应的信息，对于系统交互错误，我们使用状态码，而错误报告则相反，它是提供给人类的，要根据受众进行调整，对于操作人
员则尽可能多的错误信息，对于用户则是提供足够调整预期行为的信息即可；

export RUST_LOG="sqlx=error,info"
export TEST_LOG=enabled
cargo t subscribe_fails_if_there_is_a_fatal_database_error | bunyan
enabled: 这个值表示 “启用测试日志输出”,这三条命令组合在一起,测试运行时的所有日志都能被显示出来
日志中exception.details和exception.message记录底层的根本原因
------------------------------------------------------------------------------------------------------------------------------
8.2.1 跟踪错误的根本原因(日志中exception.details和exception.message，记录的错误日志简洁而深入); "孤儿规则":对于外来的类型，不允许实现一个外来的trait；
Debug trait应当提供一种对开发者友好的格式，尽可能将类型结构表达出来，几乎所有被设置为公开的类型都应该实现Debug,而Dispaly trait则相反，
它应当提供一种对用户友好的格式，大部分类型都不会实现Display,且不能通过#[derive(Display)]宏来自动实现；
'?'操作符帮我们自动调用'Into' trait,这样无须显示的调用'map_err'方法；
